<html><head></head><body><div class="apidocDiv">
<style>
/*csslint
*/
.apidocDiv {
    background: #fff;
    font-family: Arial, Helvetica, sans-serif;
}
.apidocDiv a[href] {
    color: #33f;
    font-weight: bold;
    text-decoration: none;
}
.apidocDiv a[href]:hover {
    text-decoration: underline;
}
.apidocCodeCommentSpan {
    background: #bbf;
    color: #000;
    display: block;
}
.apidocCodeKeywordSpan {
    color: #d00;
    font-weight: bold;
}
.apidocCodePre {
    background: #eef;
    border: 1px solid;
    color: #777;
    padding: 5px;
    white-space: pre-wrap;
}
.apidocFooterDiv {
    margin-top: 20px;
    text-align: center;
}
.apidocModuleLi {
    margin-top: 10px;
}
.apidocSectionDiv {
    border-top: 1px solid;
    margin-top: 20px;
}
.apidocSignatureSpan {
    color: #777;
    font-weight: bold;
}
</style>
<h1>api documentation for
    <a href="https://github.com/dbashford/textract">textract (v2.1.2)</a>
</h1>
<h4>Extracting text from files of various type including html, pdf, doc, docx, xls, xlsx, csv, pptx, png, jpg, gif, rtf, text/*, and various open office.</h4>
<div class="apidocSectionDiv"><a href="#apidoc.tableOfContents" id="apidoc.tableOfContents"><h1>table of contents</h1></a><ol>

    <li class="apidocModuleLi"><a href="#apidoc.module.textract">module textract</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.textract.fromBufferWithMime">
            function <span class="apidocSignatureSpan">textract.</span>fromBufferWithMime
            <span class="apidocSignatureSpan">( type, bufferContent, options, cb, withPath )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.textract.fromBufferWithName">
            function <span class="apidocSignatureSpan">textract.</span>fromBufferWithName
            <span class="apidocSignatureSpan">( filePath, bufferContent, options, cb )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.textract.fromFileWithMimeAndPath">
            function <span class="apidocSignatureSpan">textract.</span>fromFileWithMimeAndPath
            <span class="apidocSignatureSpan">( type, filePath, options, cb )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.textract.fromFileWithPath">
            function <span class="apidocSignatureSpan">textract.</span>fromFileWithPath
            <span class="apidocSignatureSpan">( filePath, options, cb )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.textract.fromUrl">
            function <span class="apidocSignatureSpan">textract.</span>fromUrl
            <span class="apidocSignatureSpan">( url, options, cb )</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">textract.</span>util</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.textract.util">module textract.util</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.textract.util.createExecOptions">
            function <span class="apidocSignatureSpan">textract.util.</span>createExecOptions
            <span class="apidocSignatureSpan">( type, options )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.textract.util.getTextFromZipFile">
            function <span class="apidocSignatureSpan">textract.util.</span>getTextFromZipFile
            <span class="apidocSignatureSpan">( zipfile, entry, cb )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.textract.util.replaceBadCharacters">
            function <span class="apidocSignatureSpan">textract.util.</span>replaceBadCharacters
            <span class="apidocSignatureSpan">( text )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.textract.util.runExecIntoFile">
            function <span class="apidocSignatureSpan">textract.util.</span>runExecIntoFile
            <span class="apidocSignatureSpan">( label, filePath, options, execOptions, genCommand, cb )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.textract.util.unzipCheck">
            function <span class="apidocSignatureSpan">textract.util.</span>unzipCheck
            <span class="apidocSignatureSpan">( type, cb )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.textract.util.yauzlError">
            function <span class="apidocSignatureSpan">textract.util.</span>yauzlError
            <span class="apidocSignatureSpan">( err, cb )</span>
            </a>

        </li>

    </ol></li>

</ol></div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.textract" id="apidoc.module.textract">module textract</a></h1>


    <h2>
        <a href="#apidoc.element.textract.fromBufferWithMime" id="apidoc.element.textract.fromBufferWithMime">
        function <span class="apidocSignatureSpan">textract.</span>fromBufferWithMime
        <span class="apidocSignatureSpan">( type, bufferContent, options, cb, withPath )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function fromBufferWithMime( type, bufferContent, options, cb, withPath ) {
  if ( typeof type === 'string' &amp;&amp;
       bufferContent &amp;&amp;
       bufferContent instanceof Buffer &amp;&amp;
       ( typeof options === 'function' || typeof cb === 'function' ) ) {
    _writeBufferToDisk( bufferContent, function( newPath ) {
      fromFileWithMimeAndPath( type, newPath, options, cb );
    });
  } else {
    _returnArgsError( arguments );
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
```javascript
textract.fromFileWithMimeAndPath(type, filePath, config, function( error, text ) {})
```

##### Buffer + mime type

```javascript
textract.<span class="apidocCodeKeywordSpan">fromBufferWithMime</span>(type, buffer, function( error, text ) {})
```

```javascript
textract.fromBufferWithMime(type, buffer, config, function( error, text ) {})
```

##### Buffer + file name/path
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.textract.fromBufferWithName" id="apidoc.element.textract.fromBufferWithName">
        function <span class="apidocSignatureSpan">textract.</span>fromBufferWithName
        <span class="apidocSignatureSpan">( filePath, bufferContent, options, cb )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function fromBufferWithName( filePath, bufferContent, options, cb ) {
  var type;
  if ( typeof filePath === 'string' ) {
    type = mime.lookup( filePath );
    fromBufferWithMime( type, bufferContent, options, cb, true );
  } else {
    _returnArgsError( arguments );
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
```javascript
textract.fromBufferWithMime(type, buffer, config, function( error, text ) {})
```

##### Buffer + file name/path

```javascript
textract.<span class="apidocCodeKeywordSpan">fromBufferWithName</span>(name, buffer, function( error, text ) {})
```

```javascript
textract.fromBufferWithName(name, buffer, config, function( error, text ) {})
```

##### URL
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.textract.fromFileWithMimeAndPath" id="apidoc.element.textract.fromFileWithMimeAndPath">
        function <span class="apidocSignatureSpan">textract.</span>fromFileWithMimeAndPath
        <span class="apidocSignatureSpan">( type, filePath, options, cb )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function fromFileWithMimeAndPath( type, filePath, options, cb ) {
  var called = false;

  if ( typeof type === 'string' &amp;&amp; typeof filePath === 'string' ) {
    if ( typeof cb === 'function' &amp;&amp; typeof options === 'object' ) {
      // (mimeType, filePath, options, callback)
      _extractWithType( type, filePath, options, cb );
      called = true;
    } else if ( typeof options === 'function' &amp;&amp; cb === undefined ) {
      // (mimeType, filePath, callback)
      _extractWithType( type, filePath, {}, options );
      called = true;
    }
  }

  if ( !called ) {
    _returnArgsError( arguments );
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

```javascript
textract.fromFileWithPath(filePath, config, function( error, text ) {})
```
##### File + mime type

```javascript
textract.<span class="apidocCodeKeywordSpan">fromFileWithMimeAndPath</span>(type, filePath, function( error, text ) {})
```

```javascript
textract.fromFileWithMimeAndPath(type, filePath, config, function( error, text ) {})
```

##### Buffer + mime type
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.textract.fromFileWithPath" id="apidoc.element.textract.fromFileWithPath">
        function <span class="apidocSignatureSpan">textract.</span>fromFileWithPath
        <span class="apidocSignatureSpan">( filePath, options, cb )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function fromFileWithPath( filePath, options, cb ) {
  var type;
  if ( typeof filePath === 'string' &amp;&amp;
       ( typeof options === 'function' || typeof cb === 'function' ) ) {
    type = ( options &amp;&amp; options.typeOverride ) || mime.lookup( filePath );
    fromFileWithMimeAndPath( type, filePath, options, cb );
  } else {
    _returnArgsError( arguments );
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
There are several ways to extract text.  For all methods, the extracted text and an error object are passed to a callback.

`error` will contain informative text about why the extraction failed. If textract does not currently extract files of the type
provided, a `typeNotFound` flag will be tossed on the error object.

##### File

```javascript
textract.<span class="apidocCodeKeywordSpan">fromFileWithPath</span>(filePath, function( error, text ) {})
```

```javascript
textract.fromFileWithPath(filePath, config, function( error, text ) {})
```
##### File + mime type
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.textract.fromUrl" id="apidoc.element.textract.fromUrl">
        function <span class="apidocSignatureSpan">textract.</span>fromUrl
        <span class="apidocSignatureSpan">( url, options, cb )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function fromUrl( url, options, cb ) {
  var urlNoQueryParams, extname, filePath, fullFilePath, file, href, callbackCalled;

  // allow url to be either a string or to be a
  // Node URL Object: https://nodejs.org/api/url.html
  href = ( typeof url === 'string' ) ? url : url.href;

  if ( href ) {
    options = options || {};
    urlNoQueryParams = href.split( '?' )[0];
    extname = path.extname( urlNoQueryParams );
    filePath = _genRandom() + extname;
    fullFilePath = path.join( tmpDir, filePath );
    file = fs.createWriteStream( fullFilePath );
    file.on( 'finish', function() {
      if ( !callbackCalled ) {
        fromFileWithPath( fullFilePath, options, cb );
      }
    });

    got.stream( url )
      .on( 'response', function( response ) {
        // allows for overriding by the developer or automatically
        // populating based on server response.
        if ( !options.typeOverride ) {
          options.typeOverride = response.headers['content-type'].split( /;/ )[0];
        }
      })
      .on( 'error', function( error ) {
        var _cb = ( typeof options === 'function' ) ? options : cb;
        callbackCalled = true;
        _cb( error );
      })
      .pipe( file );
  } else {
    _returnArgsError( arguments );
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
```

##### URL

When passing a URL, the URL can either be a string, or a [node.js URL object](https://nodejs.org/api/url.html). Using the URL object
 allows fine grained control over the URL being used.

```javascript
textract.<span class="apidocCodeKeywordSpan">fromUrl</span>(url, function( error, text ) {})
```

```javascript
textract.fromUrl(url, config, function( error, text ) {})
```

## Testing Notes
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.textract.util" id="apidoc.module.textract.util">module textract.util</a></h1>


    <h2>
        <a href="#apidoc.element.textract.util.createExecOptions" id="apidoc.element.textract.util.createExecOptions">
        function <span class="apidocSignatureSpan">textract.util.</span>createExecOptions
        <span class="apidocSignatureSpan">( type, options )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createExecOptions( type, options ) {
  var execOptions = {};
  if ( options[type] &amp;&amp; options[type].exec ) {
    execOptions = options[type].exec;
  } else {
    if ( options.exec ) {
      execOptions = options.exec;
    }
  }
  return execOptions;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.textract.util.getTextFromZipFile" id="apidoc.element.textract.util.getTextFromZipFile">
        function <span class="apidocSignatureSpan">textract.util.</span>getTextFromZipFile
        <span class="apidocSignatureSpan">( zipfile, entry, cb )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getTextFromZipFile( zipfile, entry, cb ) {
  zipfile.openReadStream( entry, function( err, readStream ) {
    var text = ''
      , error = ''
      ;

    if ( err ) {
      cb( err, null );
      return;
    }

    readStream.on( 'data', function( chunk ) {
      text += chunk;
    });
    readStream.on( 'end', function() {
      if ( error.length &gt; 0 ) {
        cb( error, null );
      } else {
        cb( null, text );
      }
    });
    readStream.on( 'error', function( _err ) {
      error += _err;
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.textract.util.replaceBadCharacters" id="apidoc.element.textract.util.replaceBadCharacters">
        function <span class="apidocSignatureSpan">textract.util.</span>replaceBadCharacters
        <span class="apidocSignatureSpan">( text )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function replaceBadCharacters( text ) {
  var i, repl;
  for ( i = 0; i &lt; rLen; i++ ) {
    repl = replacements[i];
    text = text.replace( repl[0], repl[1] );
  }
  return text;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}

// global, all file type, content cleansing
function cleanseText( options, cb ) {
  return function( error, text ) {
    if ( !error ) {
// clean up text
text = util.<span class="apidocCodeKeywordSpan">replaceBadCharacters</span>( text );

if ( options.preserveLineBreaks ) {
  text = text.replace( WHITELIST_PRESERVE_LINEBREAKS, ' ' );
} else {
  text = text.replace( WHITELIST_STRIP_LINEBREAKS, ' ' );
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.textract.util.runExecIntoFile" id="apidoc.element.textract.util.runExecIntoFile">
        function <span class="apidocSignatureSpan">textract.util.</span>runExecIntoFile
        <span class="apidocSignatureSpan">( label, filePath, options, execOptions, genCommand, cb )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function runExecIntoFile( label, filePath, options, execOptions, genCommand, cb ) {
  // escape the file paths
  var fileTempOutPath = path.join( outDir, path.basename( filePath, path.extname( filePath ) ) )
    , escapedFilePath = filePath.replace( /\s/g, '\\ ' )
    , escapedFileTempOutPath = fileTempOutPath.replace( /\s/g, '\\ ' )
    , cmd = genCommand( options, escapedFilePath, escapedFileTempOutPath )
    ;

  exec( cmd, execOptions,
    function( error /* , stdout, stderr */ ) {
      if ( error !== null ) {
        error = new Error( 'Error extracting [[ ' +
          path.basename( filePath ) + ' ]], exec error: ' + error.message );
        cb( error, null );
        return;
      }

      fs.exists( fileTempOutPath + '.txt', function( exists ) {
        if ( exists ) {
          fs.readFile( fileTempOutPath + '.txt', 'utf8', function( error2, text ) {
            if ( error2 ) {
              error2 = new Error( 'Error reading' + label +
                ' output at [[ ' + fileTempOutPath + ' ]], error: ' + error.message );
              cb( error2, null );
            } else {
              fs.unlink( fileTempOutPath + '.txt', function( error3 ) {
                if ( error3 ) {
                  error3 = new Error( 'Error, ' + label +
                    ' , cleaning up temp file [[ ' + fileTempOutPath +
                    ' ]], error: ' + error.message );
                  cb( error3, null );
                } else {
                  cb( null, text.toString() );
                }
              });
            }
          });
        } else {
          error = new Error( 'Error reading ' + label +
            ' output at [[ ' + fileTempOutPath + ' ]], file does not exist' );
          cb( error, null );
        }
      });
    }
  );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.textract.util.unzipCheck" id="apidoc.element.textract.util.unzipCheck">
        function <span class="apidocSignatureSpan">textract.util.</span>unzipCheck
        <span class="apidocSignatureSpan">( type, cb )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function unzipCheck( type, cb ) {
  exec( 'unzip',
    function( error /* , stdout, stderr */ ) {
      if ( error ) {
        // eslint-disable-next-line no-console
        console.error( 'textract: \'unzip\' does not appear to be installed, ' +
          'so textract will be unable to extract ' + type + '.' );
      }
      cb( error === null );
    }
  );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.textract.util.yauzlError" id="apidoc.element.textract.util.yauzlError">
        function <span class="apidocSignatureSpan">textract.util.</span>yauzlError
        <span class="apidocSignatureSpan">( err, cb )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function yauzlError( err, cb ) {
  var msg = err.message;
  if ( msg === 'end of central directory record signature not found' ) {
    msg = 'File not correctly recognized as zip file, ' + msg;
  }
  cb( new Error( msg ), null );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocFooterDiv">
    [ this document was created with
    <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a>
    ]
</div>
</div>
</body></html>