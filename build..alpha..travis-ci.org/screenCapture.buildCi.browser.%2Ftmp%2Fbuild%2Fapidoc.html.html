<html><head></head><body><div class="apidocDiv">
<style>
/*csslint
*/
.apidocDiv {
    background: #fff;
    font-family: Arial, Helvetica, sans-serif;
}
.apidocDiv a[href] {
    color: #33f;
    font-weight: bold;
    text-decoration: none;
}
.apidocDiv a[href]:hover {
    text-decoration: underline;
}
.apidocCodeCommentSpan {
    background: #bbf;
    color: #000;
    display: block;
}
.apidocCodeKeywordSpan {
    color: #d00;
    font-weight: bold;
}
.apidocCodePre {
    background: #eef;
    border: 1px solid;
    color: #777;
    padding: 5px;
    white-space: pre-wrap;
}
.apidocFooterDiv {
    margin-top: 20px;
    text-align: center;
}
.apidocModuleLi {
    margin-top: 10px;
}
.apidocSectionDiv {
    border-top: 1px solid;
    margin-top: 20px;
}
.apidocSignatureSpan {
    color: #777;
    font-weight: bold;
}
</style>
<h1>api documentation for
    <a href="https://github.com/dbashford/textract">textract (v2.1.2)</a>
</h1>
<h4>Extracting text from files of various type including html, pdf, doc, docx, xls, xlsx, csv, pptx, png, jpg, gif, rtf, text/*, and various open office.</h4>
<div class="apidocSectionDiv"><a href="#apidoc.tableOfContents" id="apidoc.tableOfContents"><h1>table of contents</h1></a><ol>

    <li class="apidocModuleLi"><a href="#apidoc.module.textract">module textract</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.textract.fromBufferWithMime">
            function <span class="apidocSignatureSpan">textract.</span>fromBufferWithMime
            <span class="apidocSignatureSpan">( type, bufferContent, options, cb, withPath )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.textract.fromBufferWithName">
            function <span class="apidocSignatureSpan">textract.</span>fromBufferWithName
            <span class="apidocSignatureSpan">( filePath, bufferContent, options, cb )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.textract.fromFileWithMimeAndPath">
            function <span class="apidocSignatureSpan">textract.</span>fromFileWithMimeAndPath
            <span class="apidocSignatureSpan">( type, filePath, options, cb )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.textract.fromFileWithPath">
            function <span class="apidocSignatureSpan">textract.</span>fromFileWithPath
            <span class="apidocSignatureSpan">( filePath, options, cb )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.textract.fromUrl">
            function <span class="apidocSignatureSpan">textract.</span>fromUrl
            <span class="apidocSignatureSpan">( url, options, cb )</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">textract.</span>docx</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">textract.</span>dxf</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">textract.</span>html</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">textract.</span>images</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">textract.</span>md</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">textract.</span>odt</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">textract.</span>pdf</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">textract.</span>ppt</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">textract.</span>pptx</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">textract.</span>rtf</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">textract.</span>text</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">textract.</span>util</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">textract.</span>xls</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.textract.docx">module textract.docx</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.textract.docx.extract">
            function <span class="apidocSignatureSpan">textract.docx.</span>extract
            <span class="apidocSignatureSpan">( filePath, options, cb )</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">textract.docx.</span>types</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.textract.dxf">module textract.dxf</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.textract.dxf.extract">
            function <span class="apidocSignatureSpan">textract.dxf.</span>extract
            <span class="apidocSignatureSpan">( filePath, options, cb )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.textract.dxf.test">
            function <span class="apidocSignatureSpan">textract.dxf.</span>test
            <span class="apidocSignatureSpan">( options, cb )</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">textract.dxf.</span>types</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.textract.html">module textract.html</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.textract.html.extract">
            function <span class="apidocSignatureSpan">textract.html.</span>extract
            <span class="apidocSignatureSpan">( filePath, options, cb )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.textract.html.extractFromText">
            function <span class="apidocSignatureSpan">textract.html.</span>extractFromText
            <span class="apidocSignatureSpan">( data, cb )</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">textract.html.</span>types</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.textract.images">module textract.images</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.textract.images.extract">
            function <span class="apidocSignatureSpan">textract.images.</span>extract
            <span class="apidocSignatureSpan">( filePath, options, cb )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.textract.images.test">
            function <span class="apidocSignatureSpan">textract.images.</span>test
            <span class="apidocSignatureSpan">( options, cb )</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">textract.images.</span>types</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.textract.md">module textract.md</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.textract.md.extract">
            function <span class="apidocSignatureSpan">textract.md.</span>extract
            <span class="apidocSignatureSpan">( filePath, options, cb )</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">textract.md.</span>types</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.textract.odt">module textract.odt</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.textract.odt.extract">
            function <span class="apidocSignatureSpan">textract.odt.</span>extract
            <span class="apidocSignatureSpan">( filePath, options, cb )</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">textract.odt.</span>types</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.textract.pdf">module textract.pdf</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.textract.pdf.extract">
            function <span class="apidocSignatureSpan">textract.pdf.</span>extract
            <span class="apidocSignatureSpan">( filePath, options, cb )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.textract.pdf.test">
            function <span class="apidocSignatureSpan">textract.pdf.</span>test
            <span class="apidocSignatureSpan">( options, cb )</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">textract.pdf.</span>types</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.textract.ppt">module textract.ppt</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.textract.ppt.extract">
            function <span class="apidocSignatureSpan">textract.ppt.</span>extract
            <span class="apidocSignatureSpan">( filePath, options, cb )</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">textract.ppt.</span>types</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.textract.pptx">module textract.pptx</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.textract.pptx.extract">
            function <span class="apidocSignatureSpan">textract.pptx.</span>extract
            <span class="apidocSignatureSpan">( filePath, options, cb )</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">textract.pptx.</span>types</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.textract.rtf">module textract.rtf</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.textract.rtf.extract">
            function <span class="apidocSignatureSpan">textract.rtf.</span>extract
            <span class="apidocSignatureSpan">( filePath, options, cb )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.textract.rtf.test">
            function <span class="apidocSignatureSpan">textract.rtf.</span>test
            <span class="apidocSignatureSpan">( options, cb )</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">textract.rtf.</span>types</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.textract.text">module textract.text</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.textract.text.extract">
            function <span class="apidocSignatureSpan">textract.text.</span>extract
            <span class="apidocSignatureSpan">( filePath, options, cb )</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">textract.text.</span>types</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.textract.util">module textract.util</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.textract.util.createExecOptions">
            function <span class="apidocSignatureSpan">textract.util.</span>createExecOptions
            <span class="apidocSignatureSpan">( type, options )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.textract.util.getTextFromZipFile">
            function <span class="apidocSignatureSpan">textract.util.</span>getTextFromZipFile
            <span class="apidocSignatureSpan">( zipfile, entry, cb )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.textract.util.replaceBadCharacters">
            function <span class="apidocSignatureSpan">textract.util.</span>replaceBadCharacters
            <span class="apidocSignatureSpan">( text )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.textract.util.runExecIntoFile">
            function <span class="apidocSignatureSpan">textract.util.</span>runExecIntoFile
            <span class="apidocSignatureSpan">( label, filePath, options, execOptions, genCommand, cb )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.textract.util.unzipCheck">
            function <span class="apidocSignatureSpan">textract.util.</span>unzipCheck
            <span class="apidocSignatureSpan">( type, cb )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.textract.util.yauzlError">
            function <span class="apidocSignatureSpan">textract.util.</span>yauzlError
            <span class="apidocSignatureSpan">( err, cb )</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.textract.xls">module textract.xls</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.textract.xls.extract">
            function <span class="apidocSignatureSpan">textract.xls.</span>extract
            <span class="apidocSignatureSpan">( filePath, options, cb )</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">textract.xls.</span>types</span>

        </li>

    </ol></li>

</ol></div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.textract" id="apidoc.module.textract">module textract</a></h1>


    <h2>
        <a href="#apidoc.element.textract.fromBufferWithMime" id="apidoc.element.textract.fromBufferWithMime">
        function <span class="apidocSignatureSpan">textract.</span>fromBufferWithMime
        <span class="apidocSignatureSpan">( type, bufferContent, options, cb, withPath )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function fromBufferWithMime( type, bufferContent, options, cb, withPath ) {
  if ( typeof type === 'string' &amp;&amp;
       bufferContent &amp;&amp;
       bufferContent instanceof Buffer &amp;&amp;
       ( typeof options === 'function' || typeof cb === 'function' ) ) {
    _writeBufferToDisk( bufferContent, function( newPath ) {
      fromFileWithMimeAndPath( type, newPath, options, cb );
    });
  } else {
    _returnArgsError( arguments );
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
```javascript
textract.fromFileWithMimeAndPath(type, filePath, config, function( error, text ) {})
```

##### Buffer + mime type

```javascript
textract.<span class="apidocCodeKeywordSpan">fromBufferWithMime</span>(type, buffer, function( error, text ) {})
```

```javascript
textract.fromBufferWithMime(type, buffer, config, function( error, text ) {})
```

##### Buffer + file name/path
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.textract.fromBufferWithName" id="apidoc.element.textract.fromBufferWithName">
        function <span class="apidocSignatureSpan">textract.</span>fromBufferWithName
        <span class="apidocSignatureSpan">( filePath, bufferContent, options, cb )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function fromBufferWithName( filePath, bufferContent, options, cb ) {
  var type;
  if ( typeof filePath === 'string' ) {
    type = mime.lookup( filePath );
    fromBufferWithMime( type, bufferContent, options, cb, true );
  } else {
    _returnArgsError( arguments );
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
```javascript
textract.fromBufferWithMime(type, buffer, config, function( error, text ) {})
```

##### Buffer + file name/path

```javascript
textract.<span class="apidocCodeKeywordSpan">fromBufferWithName</span>(name, buffer, function( error, text ) {})
```

```javascript
textract.fromBufferWithName(name, buffer, config, function( error, text ) {})
```

##### URL
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.textract.fromFileWithMimeAndPath" id="apidoc.element.textract.fromFileWithMimeAndPath">
        function <span class="apidocSignatureSpan">textract.</span>fromFileWithMimeAndPath
        <span class="apidocSignatureSpan">( type, filePath, options, cb )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function fromFileWithMimeAndPath( type, filePath, options, cb ) {
  var called = false;

  if ( typeof type === 'string' &amp;&amp; typeof filePath === 'string' ) {
    if ( typeof cb === 'function' &amp;&amp; typeof options === 'object' ) {
      // (mimeType, filePath, options, callback)
      _extractWithType( type, filePath, options, cb );
      called = true;
    } else if ( typeof options === 'function' &amp;&amp; cb === undefined ) {
      // (mimeType, filePath, callback)
      _extractWithType( type, filePath, {}, options );
      called = true;
    }
  }

  if ( !called ) {
    _returnArgsError( arguments );
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

```javascript
textract.fromFileWithPath(filePath, config, function( error, text ) {})
```
##### File + mime type

```javascript
textract.<span class="apidocCodeKeywordSpan">fromFileWithMimeAndPath</span>(type, filePath, function( error, text ) {})
```

```javascript
textract.fromFileWithMimeAndPath(type, filePath, config, function( error, text ) {})
```

##### Buffer + mime type
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.textract.fromFileWithPath" id="apidoc.element.textract.fromFileWithPath">
        function <span class="apidocSignatureSpan">textract.</span>fromFileWithPath
        <span class="apidocSignatureSpan">( filePath, options, cb )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function fromFileWithPath( filePath, options, cb ) {
  var type;
  if ( typeof filePath === 'string' &amp;&amp;
       ( typeof options === 'function' || typeof cb === 'function' ) ) {
    type = ( options &amp;&amp; options.typeOverride ) || mime.lookup( filePath );
    fromFileWithMimeAndPath( type, filePath, options, cb );
  } else {
    _returnArgsError( arguments );
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
There are several ways to extract text.  For all methods, the extracted text and an error object are passed to a callback.

`error` will contain informative text about why the extraction failed. If textract does not currently extract files of the type
provided, a `typeNotFound` flag will be tossed on the error object.

##### File

```javascript
textract.<span class="apidocCodeKeywordSpan">fromFileWithPath</span>(filePath, function( error, text ) {})
```

```javascript
textract.fromFileWithPath(filePath, config, function( error, text ) {})
```
##### File + mime type
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.textract.fromUrl" id="apidoc.element.textract.fromUrl">
        function <span class="apidocSignatureSpan">textract.</span>fromUrl
        <span class="apidocSignatureSpan">( url, options, cb )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function fromUrl( url, options, cb ) {
  var urlNoQueryParams, extname, filePath, fullFilePath, file, href, callbackCalled;

  // allow url to be either a string or to be a
  // Node URL Object: https://nodejs.org/api/url.html
  href = ( typeof url === 'string' ) ? url : url.href;

  if ( href ) {
    options = options || {};
    urlNoQueryParams = href.split( '?' )[0];
    extname = path.extname( urlNoQueryParams );
    filePath = _genRandom() + extname;
    fullFilePath = path.join( tmpDir, filePath );
    file = fs.createWriteStream( fullFilePath );
    file.on( 'finish', function() {
      if ( !callbackCalled ) {
        fromFileWithPath( fullFilePath, options, cb );
      }
    });

    got.stream( url )
      .on( 'response', function( response ) {
        // allows for overriding by the developer or automatically
        // populating based on server response.
        if ( !options.typeOverride ) {
          options.typeOverride = response.headers['content-type'].split( /;/ )[0];
        }
      })
      .on( 'error', function( error ) {
        var _cb = ( typeof options === 'function' ) ? options : cb;
        callbackCalled = true;
        _cb( error );
      })
      .pipe( file );
  } else {
    _returnArgsError( arguments );
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
```

##### URL

When passing a URL, the URL can either be a string, or a [node.js URL object](https://nodejs.org/api/url.html). Using the URL object
 allows fine grained control over the URL being used.

```javascript
textract.<span class="apidocCodeKeywordSpan">fromUrl</span>(url, function( error, text ) {})
```

```javascript
textract.fromUrl(url, config, function( error, text ) {})
```

## Testing Notes
...</pre></li>
    </ul>




























</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.textract.docx" id="apidoc.module.textract.docx">module textract.docx</a></h1>


    <h2>
        <a href="#apidoc.element.textract.docx.extract" id="apidoc.element.textract.docx.extract">
        function <span class="apidocSignatureSpan">textract.docx.</span>extract
        <span class="apidocSignatureSpan">( filePath, options, cb )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function extractText( filePath, options, cb ) {
  var result = '';

  yauzl.open( filePath, function( err, zipfile ) {
    var processEnd
      , processedEntries = 0
      ;

    if ( err ) {
      util.yauzlError( err, cb );
      return;
    }

    processEnd = function() {
      var text;
      if ( zipfile.entryCount === ++processedEntries ) {
        if ( result.length ) {
          text = _calculateExtractedText( result );
          cb( null, text );
        } else {
          cb( new Error(
            'Extraction could not find content in file, are you' +
            ' sure it is the mime type it says it is?' ),
            null );
        }
      }
    };

    zipfile.on( 'entry', function( entry ) {
      if ( includeRegex.test( entry.fileName ) &amp;&amp; !excludeRegex.test( entry.fileName ) ) {
        util.getTextFromZipFile( zipfile, entry, function( err2, text ) {
          result += text + '\n';
          processEnd();
        });
      } else {
        processEnd();
      }
    });

    zipfile.on( 'error', function( err3 ) {
      cb( err3 );
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.textract.dxf" id="apidoc.module.textract.dxf">module textract.dxf</a></h1>


    <h2>
        <a href="#apidoc.element.textract.dxf.extract" id="apidoc.element.textract.dxf.extract">
        function <span class="apidocSignatureSpan">textract.dxf.</span>extract
        <span class="apidocSignatureSpan">( filePath, options, cb )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function extractText( filePath, options, cb ) {
  var execOptions = util.createExecOptions( 'dxf', options )
    , escapedPath = filePath.replace( /\s/g, '\\ ' )
    ;

  exec( 'drawingtotext ' + escapedPath,
    execOptions,
    function( error, stdout, stderr ) {
      if ( stderr !== '' ) {
        error = new Error( 'error extracting DXF text ' +
          path.basename( filePath ) + ': ' + stderr );
        cb( error, null );
        return;
      }

      cb( null, stdout );
    }
  );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.textract.dxf.test" id="apidoc.element.textract.dxf.test">
        function <span class="apidocSignatureSpan">textract.dxf.</span>test
        <span class="apidocSignatureSpan">( options, cb )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function testForBinary( options, cb ) {
  exec( 'drawingtotext notalegalfile',
    function( error, stdout, stderr ) {
      var msg
        , errorRegex = /I couldn't make sense of your input/
        ;

      if ( !( stderr &amp;&amp; errorRegex.test( stderr ) ) ) {
        msg = 'INFO: \'drawingtotext\' does not appear to be installed, ' +
          'so textract will be unable to extract DXFs.';
        cb( false, msg );
      } else {
        cb( true );
      }
    }
  );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  extractor.types.forEach( function( type ) {
    failedExtractorTypes[type.toLowerCase()] = failedMessage;
  });
}
}

function testExtractor( extractor, options ) {
extractor.<span class="apidocCodeKeywordSpan">test</span>( options, function( passedTest, failedMessage ) {
  satisfiedExtractors++;
  if ( passedTest ) {
    registerExtractor( extractor );
  } else {
    registerFailedExtractor( extractor, failedMessage );
  }
});
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.textract.html" id="apidoc.module.textract.html">module textract.html</a></h1>


    <h2>
        <a href="#apidoc.element.textract.html.extract" id="apidoc.element.textract.html.extract">
        function <span class="apidocSignatureSpan">textract.html.</span>extract
        <span class="apidocSignatureSpan">( filePath, options, cb )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function extractText( filePath, options, cb ) {
  fs.readFile( filePath, function( error, data ) {
    if ( error ) {
      cb( error, null );
      return;
    }
    extractFromText( data, cb );
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.textract.html.extractFromText" id="apidoc.element.textract.html.extractFromText">
        function <span class="apidocSignatureSpan">textract.html.</span>extractFromText
        <span class="apidocSignatureSpan">( data, cb )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function extractFromText( data, cb ) {
  var $, text;

  text = data.toString()
    .replace( /&lt; *(br|p|div|section|aside|button|header|footer|li|article|blockquote|cite|code|h1|h2|h3|h4|h5|h6|legend|nav)((.*?)&gt;)/
g, '&lt;$1$2|||||' )
    .replace( /&lt; *\/(td|a|option) *&gt;/g, ' &lt;/$1&gt;' ) // spacing some things out so text doesn't get smashed together
    .replace( /&lt; *(a|td|option)/g, ' &lt;$1' ) // spacing out links
    .replace( /&lt; *(br|hr) +\/&gt;/g, '|||||&lt;$1\\&gt;' )
    .replace( /&lt;\/ +?(p|div|section|aside|button|header|footer|li|article|blockquote|cite|code|h1|h2|h3|h4|h5|h6|legend|nav)&gt;/g, '|||||&lt;/$
1&gt;' );

  text = '&lt;textractwrapper&gt;' + text + '&lt;textractwrapper&gt;';

  try {
    $ = cheerio.load( text );
    $( 'script' ).remove();
    $( 'style' ).remove();
    $( 'noscript' ).remove();

    text = $( 'textractwrapper' ).text().replace( /\|\|\|\|\|/g, '\n' )
      .replace( /(\n\u00A0|\u00A0\n|\n | \n)+/g, '\n' )
      .replace( /(\r\u00A0|\u00A0\r|\r | \r)+/g, '\n' )
      .replace( /(\v\u00A0|\u00A0\v|\v | \v)+/g, '\n' )
      .replace( /(\t\u00A0|\u00A0\t|\t | \t)+/g, '\n' )
      .replace( /[\n\r\t\v]+/g, '\n' )
      ;
  } catch ( err ) {
    cb( err, null );
    return;
  }

  cb( null, text );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    return;
  }

  marked( data.toString(), function( err, content ) {
    if ( err ) {
      cb( err, null );
    } else {
      htmlExtract.<span class="apidocCodeKeywordSpan">extractFromText</span>( content, cb );
    }
  });
});
}

module.exports = {
types: ['text/x-markdown'],
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.textract.images" id="apidoc.module.textract.images">module textract.images</a></h1>


    <h2>
        <a href="#apidoc.element.textract.images.extract" id="apidoc.element.textract.images.extract">
        function <span class="apidocSignatureSpan">textract.images.</span>extract
        <span class="apidocSignatureSpan">( filePath, options, cb )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function extractText( filePath, options, cb ) {
  var execOptions = util.createExecOptions( 'images', options );
  util.runExecIntoFile( 'tesseract', filePath, options,
    execOptions, tesseractExtractionCommand, cb );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.textract.images.test" id="apidoc.element.textract.images.test">
        function <span class="apidocSignatureSpan">textract.images.</span>test
        <span class="apidocSignatureSpan">( options, cb )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function testForBinary( options, cb ) {
  exec( 'tesseract',
    function( error, stdout, stderr ) {
      var msg;
      // checking for content of help text
      if ( ( error &amp;&amp; error.toString().indexOf( 'Usage:' ) &gt; -1 ) ||
          ( stderr &amp;&amp; stderr.toString().indexOf( 'Usage:' ) &gt; -1 ) ||
          ( stdout &amp;&amp; stdout.toString().indexOf( 'Usage:' ) &gt; -1 ) ) {
        cb( true );
      } else {
        msg = 'INFO: \'tesseract\' does not appear to be installed, ' +
         'so textract will be unable to extract images.';
        cb( false, msg );
      }
    }
  );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  extractor.types.forEach( function( type ) {
    failedExtractorTypes[type.toLowerCase()] = failedMessage;
  });
}
}

function testExtractor( extractor, options ) {
extractor.<span class="apidocCodeKeywordSpan">test</span>( options, function( passedTest, failedMessage ) {
  satisfiedExtractors++;
  if ( passedTest ) {
    registerExtractor( extractor );
  } else {
    registerFailedExtractor( extractor, failedMessage );
  }
});
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.textract.md" id="apidoc.module.textract.md">module textract.md</a></h1>


    <h2>
        <a href="#apidoc.element.textract.md.extract" id="apidoc.element.textract.md.extract">
        function <span class="apidocSignatureSpan">textract.md.</span>extract
        <span class="apidocSignatureSpan">( filePath, options, cb )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function extractText( filePath, options, cb ) {
  fs.readFile( filePath, function( error, data ) {
    if ( error ) {
      cb( error, null );
      return;
    }

    marked( data.toString(), function( err, content ) {
      if ( err ) {
        cb( err, null );
      } else {
        htmlExtract.extractFromText( content, cb );
      }
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.textract.odt" id="apidoc.module.textract.odt">module textract.odt</a></h1>


    <h2>
        <a href="#apidoc.element.textract.odt.extract" id="apidoc.element.textract.odt.extract">
        function <span class="apidocSignatureSpan">textract.odt.</span>extract
        <span class="apidocSignatureSpan">( filePath, options, cb )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function extractText( filePath, options, cb ) {
  yauzl.open( filePath, function( err, zipfile ) {
    var textOnTheWay = false;

    if ( err ) {
      util.yauzlError( err, cb );
      return;
    }

    zipfile.on( 'end', function() {
      if ( !textOnTheWay ) {
        cb(
          new Error( 'Extraction could not find content.xml in file, ' +
            'are you sure it is the mime type it says it is?' ),
          null );
      }
    });

    zipfile.on( 'entry', function( entry ) {
      if ( entry.fileName === 'content.xml' ) {
        textOnTheWay = true;
        util.getTextFromZipFile( zipfile, entry, function( err2, text ) {
          var output = text
              .replace( 'inflating: content.xml', '' )
              .replace( /^(.Archive).*/, '' )
              .replace( /text:p/g, 'textractTextNode' )
              .replace( /text:h/g, 'textractTextNode' )
              .replace( /&lt;textractTextNode\/&gt;/g, '' )
              .trim()
            , $ = cheerio.load( '&lt;body&gt;' + output + '&lt;/body&gt;' )
            , nodes = $( 'textractTextNode' )
            , nodeTexts = []
            , i
            ;

          for ( i = 0; i &lt; nodes.length; i++ ) {
            nodeTexts.push( $( nodes[i] ).text() );
          }

          cb( null, nodeTexts.join( '\n' ) );
        });
      }
    });

    zipfile.on( 'error', function( err3 ) {
      cb( err3 );
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.textract.pdf" id="apidoc.module.textract.pdf">module textract.pdf</a></h1>


    <h2>
        <a href="#apidoc.element.textract.pdf.extract" id="apidoc.element.textract.pdf.extract">
        function <span class="apidocSignatureSpan">textract.pdf.</span>extract
        <span class="apidocSignatureSpan">( filePath, options, cb )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function extractText( filePath, options, cb ) {
  // See https://github.com/dbashford/textract/issues/75 for description of
  // what is happening here
  var pdftotextOptions = options.pdftotextOptions || { layout: 'raw' };

  extract( filePath, pdftotextOptions, function( error, pages ) {
    var fullText;
    if ( error ) {
      error = new Error( 'Error extracting PDF text for file at [[ ' +
        path.basename( filePath ) + ' ]], error: ' + error.message );
      cb( error, null );
      return;
    }
    fullText = pages.join( ' ' ).trim();
    cb( null, fullText );
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.textract.pdf.test" id="apidoc.element.textract.pdf.test">
        function <span class="apidocSignatureSpan">textract.pdf.</span>test
        <span class="apidocSignatureSpan">( options, cb )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function testForBinary( options, cb ) {
  exec( 'pdftotext -v',
    function( error, stdout, stderr ) {
      var msg;
      if ( stderr &amp;&amp; stderr.indexOf( 'pdftotext version' ) &gt; -1 ) {
        cb( true );
      } else {
        msg = 'INFO: \'pdftotext\' does not appear to be installed, ' +
         'so textract will be unable to extract PDFs.';
        cb( false, msg );
      }
    }
  );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  extractor.types.forEach( function( type ) {
    failedExtractorTypes[type.toLowerCase()] = failedMessage;
  });
}
}

function testExtractor( extractor, options ) {
extractor.<span class="apidocCodeKeywordSpan">test</span>( options, function( passedTest, failedMessage ) {
  satisfiedExtractors++;
  if ( passedTest ) {
    registerExtractor( extractor );
  } else {
    registerFailedExtractor( extractor, failedMessage );
  }
});
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.textract.ppt" id="apidoc.module.textract.ppt">module textract.ppt</a></h1>


    <h2>
        <a href="#apidoc.element.textract.ppt.extract" id="apidoc.element.textract.ppt.extract">
        function <span class="apidocSignatureSpan">textract.ppt.</span>extract
        <span class="apidocSignatureSpan">( filePath, options, cb )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">extract = function ( filePath, options, cb ) {
<span class="apidocCodeCommentSpan">  /*
  var captured = ppt.readFile(filePath);
  console.log('CAPTURED!!!!')
  console.log(captured)
  console.log('CAPTURED!!!!')
  cb( null, null );
    if ( error ) {
      cb( error, null );
      return;
    }
    cb( null, data.toString() );
  */
</span>}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.textract.pptx" id="apidoc.module.textract.pptx">module textract.pptx</a></h1>


    <h2>
        <a href="#apidoc.element.textract.pptx.extract" id="apidoc.element.textract.pptx.extract">
        function <span class="apidocSignatureSpan">textract.pptx.</span>extract
        <span class="apidocSignatureSpan">( filePath, options, cb )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function extractText( filePath, options, cb ) {
  var slides = [];

  yauzl.open( filePath, function( err, zipfile ) {
    if ( err ) {
      util.yauzlError( err, cb );
      return;
    }

    zipfile.on( 'end', function() {
      var slidesText, text;
      if ( slides.length ) {
        slides.sort( _compareSlides );
        slidesText = slides.map( function( slide ) {
          return slide.text;
        }).join( '\n' );
        text = _calculateExtractedText( slidesText );
        cb( null, text );
      } else {
        cb(
          new Error( 'Extraction could not find slides in file, are you' +
            ' sure it is the mime type it says it is?' ),
          null );
      }
    });

    zipfile.on( 'entry', function( entry ) {
      if ( slideMatch.test( entry.fileName ) ) {
        util.getTextFromZipFile( zipfile, entry, function( err2, text ) {
          var slide = +entry.fileName.replace( 'ppt/slides/slide', '' ).replace( '.xml', '' );
          slides.push({ slide: slide, text: text });
        });
      }
    });

    zipfile.on( 'error', function( err3 ) {
      cb( err3 );
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.textract.rtf" id="apidoc.module.textract.rtf">module textract.rtf</a></h1>


    <h2>
        <a href="#apidoc.element.textract.rtf.extract" id="apidoc.element.textract.rtf.extract">
        function <span class="apidocSignatureSpan">textract.rtf.</span>extract
        <span class="apidocSignatureSpan">( filePath, options, cb )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function extractText( filePath, options, cb ) {
  var escapedPath = filePath.replace( /\s/g, '\\ ' );

  // Going to output html from unrtf because unrtf does a great job of
  // going to html, but does a crap job of going to text. It leaves sections
  // out, strips apostrophes, leaves nasty quotes in for bullets and more
  // that I've likely not yet discovered.
  //
  // textract can go from html to text on its own, so let unrtf go to html
  // then extract the text from that
  //
  // Also do not have to worry about stripping comments from unrtf text
  // output since HTML comments are not included in output. Also, the
  // unrtf --quiet option doesn't work.
  exec( 'unrtf --html --nopict ' + escapedPath,
    function( error, stdout /* , stderr */ ) {
      var err;
      if ( error ) {
        err = new Error( 'unrtf read of file named [[ ' +
          path.basename( filePath ) + ' ]] failed: ' + error );
        cb( err, null );
      } else {
        htmlExtract.extractFromText( stdout.trim(), cb );
      }
    }
  );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.textract.rtf.test" id="apidoc.element.textract.rtf.test">
        function <span class="apidocSignatureSpan">textract.rtf.</span>test
        <span class="apidocSignatureSpan">( options, cb )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function testForBinary( options, cb ) {
  // just non-osx extractor
  if ( os.platform() === 'darwin' ) {
    cb( true );
    return;
  }

  exec( 'unrtf ' + __filename,
    function( error /* , stdout, stderr */ ) {
      var msg;
      if ( error !== null &amp;&amp; error.message &amp;&amp;
          error.message.indexOf( 'not found' ) !== -1 ) {
        msg = 'INFO: \'unrtf\' does not appear to be installed, ' +
          'so textract will be unable to extract RTFs.';
        cb( false, msg );
      } else {
        cb( true );
      }
    }
  );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  extractor.types.forEach( function( type ) {
    failedExtractorTypes[type.toLowerCase()] = failedMessage;
  });
}
}

function testExtractor( extractor, options ) {
extractor.<span class="apidocCodeKeywordSpan">test</span>( options, function( passedTest, failedMessage ) {
  satisfiedExtractors++;
  if ( passedTest ) {
    registerExtractor( extractor );
  } else {
    registerFailedExtractor( extractor, failedMessage );
  }
});
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.textract.text" id="apidoc.module.textract.text">module textract.text</a></h1>


    <h2>
        <a href="#apidoc.element.textract.text.extract" id="apidoc.element.textract.text.extract">
        function <span class="apidocSignatureSpan">textract.text.</span>extract
        <span class="apidocSignatureSpan">( filePath, options, cb )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function extractText( filePath, options, cb ) {
  fs.readFile( filePath, function( error, data ) {
    var encoding, decoded;
    if ( error ) {
      cb( error, null );
      return;
    }
    try {
      encoding = jschardet.detect( data ).encoding.toLowerCase();
      decoded = iconv.decode( data, encoding );
    } catch ( e ) {
      cb( e );
      return;
    }
    cb( null, decoded );
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.textract.util" id="apidoc.module.textract.util">module textract.util</a></h1>


    <h2>
        <a href="#apidoc.element.textract.util.createExecOptions" id="apidoc.element.textract.util.createExecOptions">
        function <span class="apidocSignatureSpan">textract.util.</span>createExecOptions
        <span class="apidocSignatureSpan">( type, options )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createExecOptions( type, options ) {
  var execOptions = {};
  if ( options[type] &amp;&amp; options[type].exec ) {
    execOptions = options[type].exec;
  } else {
    if ( options.exec ) {
      execOptions = options.exec;
    }
  }
  return execOptions;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var exec = require( 'child_process' ).exec
, path = require( 'path' )
, util = require( '../util' )
;

function extractText( filePath, options, cb ) {
var execOptions = util.<span class="apidocCodeKeywordSpan">createExecOptions</span>( 'dxf', options )
  , escapedPath = filePath.replace( /\s/g, '\\ ' )
  ;

exec( 'drawingtotext ' + escapedPath,
  execOptions,
  function( error, stdout, stderr ) {
    if ( stderr !== '' ) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.textract.util.getTextFromZipFile" id="apidoc.element.textract.util.getTextFromZipFile">
        function <span class="apidocSignatureSpan">textract.util.</span>getTextFromZipFile
        <span class="apidocSignatureSpan">( zipfile, entry, cb )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getTextFromZipFile( zipfile, entry, cb ) {
  zipfile.openReadStream( entry, function( err, readStream ) {
    var text = ''
      , error = ''
      ;

    if ( err ) {
      cb( err, null );
      return;
    }

    readStream.on( 'data', function( chunk ) {
      text += chunk;
    });
    readStream.on( 'end', function() {
      if ( error.length &gt; 0 ) {
        cb( error, null );
      } else {
        cb( null, text );
      }
    });
    readStream.on( 'error', function( _err ) {
      error += _err;
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        null );
    }
  }
};

zipfile.on( 'entry', function( entry ) {
  if ( includeRegex.test( entry.fileName ) &amp;&amp; !excludeRegex.test( entry.fileName ) ) {
    util.<span class="apidocCodeKeywordSpan">getTextFromZipFile</span>( zipfile, entry, function( err2, text ) {
      result += text + '\n';
      processEnd();
    });
  } else {
    processEnd();
  }
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.textract.util.replaceBadCharacters" id="apidoc.element.textract.util.replaceBadCharacters">
        function <span class="apidocSignatureSpan">textract.util.</span>replaceBadCharacters
        <span class="apidocSignatureSpan">( text )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function replaceBadCharacters( text ) {
  var i, repl;
  for ( i = 0; i &lt; rLen; i++ ) {
    repl = replacements[i];
    text = text.replace( repl[0], repl[1] );
  }
  return text;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}

// global, all file type, content cleansing
function cleanseText( options, cb ) {
  return function( error, text ) {
    if ( !error ) {
// clean up text
text = util.<span class="apidocCodeKeywordSpan">replaceBadCharacters</span>( text );

if ( options.preserveLineBreaks ) {
  text = text.replace( WHITELIST_PRESERVE_LINEBREAKS, ' ' );
} else {
  text = text.replace( WHITELIST_STRIP_LINEBREAKS, ' ' );
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.textract.util.runExecIntoFile" id="apidoc.element.textract.util.runExecIntoFile">
        function <span class="apidocSignatureSpan">textract.util.</span>runExecIntoFile
        <span class="apidocSignatureSpan">( label, filePath, options, execOptions, genCommand, cb )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function runExecIntoFile( label, filePath, options, execOptions, genCommand, cb ) {
  // escape the file paths
  var fileTempOutPath = path.join( outDir, path.basename( filePath, path.extname( filePath ) ) )
    , escapedFilePath = filePath.replace( /\s/g, '\\ ' )
    , escapedFileTempOutPath = fileTempOutPath.replace( /\s/g, '\\ ' )
    , cmd = genCommand( options, escapedFilePath, escapedFileTempOutPath )
    ;

  exec( cmd, execOptions,
    function( error /* , stdout, stderr */ ) {
      if ( error !== null ) {
        error = new Error( 'Error extracting [[ ' +
          path.basename( filePath ) + ' ]], exec error: ' + error.message );
        cb( error, null );
        return;
      }

      fs.exists( fileTempOutPath + '.txt', function( exists ) {
        if ( exists ) {
          fs.readFile( fileTempOutPath + '.txt', 'utf8', function( error2, text ) {
            if ( error2 ) {
              error2 = new Error( 'Error reading' + label +
                ' output at [[ ' + fileTempOutPath + ' ]], error: ' + error.message );
              cb( error2, null );
            } else {
              fs.unlink( fileTempOutPath + '.txt', function( error3 ) {
                if ( error3 ) {
                  error3 = new Error( 'Error, ' + label +
                    ' , cleaning up temp file [[ ' + fileTempOutPath +
                    ' ]], error: ' + error.message );
                  cb( error3, null );
                } else {
                  cb( null, text.toString() );
                }
              });
            }
          });
        } else {
          error = new Error( 'Error reading ' + label +
            ' output at [[ ' + fileTempOutPath + ' ]], file does not exist' );
          cb( error, null );
        }
      });
    }
  );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}
cmd += ' quiet';
return cmd;
}

function extractText( filePath, options, cb ) {
var execOptions = util.createExecOptions( 'images', options );
util.<span class="apidocCodeKeywordSpan">runExecIntoFile</span>( 'tesseract', filePath, options,
  execOptions, tesseractExtractionCommand, cb );
}

function testForBinary( options, cb ) {
exec( 'tesseract',
  function( error, stdout, stderr ) {
    var msg;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.textract.util.unzipCheck" id="apidoc.element.textract.util.unzipCheck">
        function <span class="apidocSignatureSpan">textract.util.</span>unzipCheck
        <span class="apidocSignatureSpan">( type, cb )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function unzipCheck( type, cb ) {
  exec( 'unzip',
    function( error /* , stdout, stderr */ ) {
      if ( error ) {
        // eslint-disable-next-line no-console
        console.error( 'textract: \'unzip\' does not appear to be installed, ' +
          'so textract will be unable to extract ' + type + '.' );
      }
      cb( error === null );
    }
  );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.textract.util.yauzlError" id="apidoc.element.textract.util.yauzlError">
        function <span class="apidocSignatureSpan">textract.util.</span>yauzlError
        <span class="apidocSignatureSpan">( err, cb )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function yauzlError( err, cb ) {
  var msg = err.message;
  if ( msg === 'end of central directory record signature not found' ) {
    msg = 'File not correctly recognized as zip file, ' + msg;
  }
  cb( new Error( msg ), null );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

  yauzl.open( filePath, function( err, zipfile ) {
var processEnd
  , processedEntries = 0
  ;

if ( err ) {
  util.<span class="apidocCodeKeywordSpan">yauzlError</span>( err, cb );
  return;
}

processEnd = function() {
  var text;
  if ( zipfile.entryCount === ++processedEntries ) {
    if ( result.length ) {
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.textract.xls" id="apidoc.module.textract.xls">module textract.xls</a></h1>


    <h2>
        <a href="#apidoc.element.textract.xls.extract" id="apidoc.element.textract.xls.extract">
        function <span class="apidocSignatureSpan">textract.xls.</span>extract
        <span class="apidocSignatureSpan">( filePath, options, cb )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function extractText( filePath, options, cb ) {
  var CSVs, wb, result, error;

  try {
    wb = J.readFile( filePath );
    CSVs = J.utils.to_csv( wb );
  } catch ( err ) {
    error = new Error( 'Could not extract ' + path.basename( filePath ) + ', ' + err );
    cb( error, null );
    return;
  }

  result = '';
  Object.keys( CSVs ).forEach( function( key ) {
    result += CSVs[key];
  });

  cb( null, result );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocFooterDiv">
    [ this document was created with
    <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a>
    ]
</div>
</div>
</body></html>