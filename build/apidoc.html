<div class="apidocDiv">
<style>
/*csslint
*/
.apidocDiv {
    background: #fff;
    font-family: Arial, Helvetica, sans-serif;
}
.apidocDiv a[href] {
    color: #33f;
    font-weight: bold;
    text-decoration: none;
}
.apidocDiv a[href]:hover {
    text-decoration: underline;
}
.apidocCodeCommentSpan {
    background: #bbf;
    color: #000;
    display: block;
}
.apidocCodeKeywordSpan {
    color: #d00;
    font-weight: bold;
}
.apidocCodePre {
    background: #eef;
    border: 1px solid;
    color: #777;
    padding: 5px;
    white-space: pre-wrap;
}
.apidocFooterDiv {
    margin-top: 20px;
    text-align: center;
}
.apidocModuleLi {
    margin-top: 10px;
}
.apidocSectionDiv {
    border-top: 1px solid;
    margin-top: 20px;
}
.apidocSignatureSpan {
    color: #777;
    font-weight: bold;
}
</style>
<h1>api documentation for
    <a

        href="https://github.com/dbashford/textract"

    >textract (v2.1.2)</a>
</h1>
<h4>Extracting text from files of various type including html, pdf, doc, docx, xls, xlsx, csv, pptx, png, jpg, gif, rtf, text/*, and various open office.</h4>
<div class="apidocSectionDiv"><a
    href="#apidoc.tableOfContents"
    id="apidoc.tableOfContents"
><h1>table of contents</h1></a><ol>

    <li class="apidocModuleLi"><a href="#apidoc.module.textract">module textract</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.textract.fromBufferWithMime">
            function <span class="apidocSignatureSpan">textract.</span>fromBufferWithMime
            <span class="apidocSignatureSpan">( type, bufferContent, options, cb, withPath )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.textract.fromBufferWithName">
            function <span class="apidocSignatureSpan">textract.</span>fromBufferWithName
            <span class="apidocSignatureSpan">( filePath, bufferContent, options, cb )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.textract.fromFileWithMimeAndPath">
            function <span class="apidocSignatureSpan">textract.</span>fromFileWithMimeAndPath
            <span class="apidocSignatureSpan">( type, filePath, options, cb )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.textract.fromFileWithPath">
            function <span class="apidocSignatureSpan">textract.</span>fromFileWithPath
            <span class="apidocSignatureSpan">( filePath, options, cb )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.textract.fromUrl">
            function <span class="apidocSignatureSpan">textract.</span>fromUrl
            <span class="apidocSignatureSpan">( url, options, cb )</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">textract.</span>docx</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">textract.</span>dxf</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">textract.</span>html</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">textract.</span>images</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">textract.</span>md</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">textract.</span>odt</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">textract.</span>pdf</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">textract.</span>ppt</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">textract.</span>pptx</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">textract.</span>rtf</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">textract.</span>text</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">textract.</span>util</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">textract.</span>xls</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.textract.docx">module textract.docx</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.textract.docx.extract">
            function <span class="apidocSignatureSpan">textract.docx.</span>extract
            <span class="apidocSignatureSpan">( filePath, options, cb )</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">textract.docx.</span>types</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.textract.dxf">module textract.dxf</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.textract.dxf.extract">
            function <span class="apidocSignatureSpan">textract.dxf.</span>extract
            <span class="apidocSignatureSpan">( filePath, options, cb )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.textract.dxf.test">
            function <span class="apidocSignatureSpan">textract.dxf.</span>test
            <span class="apidocSignatureSpan">( options, cb )</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">textract.dxf.</span>types</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.textract.html">module textract.html</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.textract.html.extract">
            function <span class="apidocSignatureSpan">textract.html.</span>extract
            <span class="apidocSignatureSpan">( filePath, options, cb )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.textract.html.extractFromText">
            function <span class="apidocSignatureSpan">textract.html.</span>extractFromText
            <span class="apidocSignatureSpan">( data, cb )</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">textract.html.</span>types</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.textract.images">module textract.images</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.textract.images.extract">
            function <span class="apidocSignatureSpan">textract.images.</span>extract
            <span class="apidocSignatureSpan">( filePath, options, cb )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.textract.images.test">
            function <span class="apidocSignatureSpan">textract.images.</span>test
            <span class="apidocSignatureSpan">( options, cb )</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">textract.images.</span>types</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.textract.md">module textract.md</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.textract.md.extract">
            function <span class="apidocSignatureSpan">textract.md.</span>extract
            <span class="apidocSignatureSpan">( filePath, options, cb )</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">textract.md.</span>types</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.textract.odt">module textract.odt</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.textract.odt.extract">
            function <span class="apidocSignatureSpan">textract.odt.</span>extract
            <span class="apidocSignatureSpan">( filePath, options, cb )</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">textract.odt.</span>types</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.textract.pdf">module textract.pdf</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.textract.pdf.extract">
            function <span class="apidocSignatureSpan">textract.pdf.</span>extract
            <span class="apidocSignatureSpan">( filePath, options, cb )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.textract.pdf.test">
            function <span class="apidocSignatureSpan">textract.pdf.</span>test
            <span class="apidocSignatureSpan">( options, cb )</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">textract.pdf.</span>types</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.textract.ppt">module textract.ppt</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.textract.ppt.extract">
            function <span class="apidocSignatureSpan">textract.ppt.</span>extract
            <span class="apidocSignatureSpan">( filePath, options, cb )</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">textract.ppt.</span>types</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.textract.pptx">module textract.pptx</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.textract.pptx.extract">
            function <span class="apidocSignatureSpan">textract.pptx.</span>extract
            <span class="apidocSignatureSpan">( filePath, options, cb )</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">textract.pptx.</span>types</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.textract.rtf">module textract.rtf</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.textract.rtf.extract">
            function <span class="apidocSignatureSpan">textract.rtf.</span>extract
            <span class="apidocSignatureSpan">( filePath, options, cb )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.textract.rtf.test">
            function <span class="apidocSignatureSpan">textract.rtf.</span>test
            <span class="apidocSignatureSpan">( options, cb )</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">textract.rtf.</span>types</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.textract.text">module textract.text</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.textract.text.extract">
            function <span class="apidocSignatureSpan">textract.text.</span>extract
            <span class="apidocSignatureSpan">( filePath, options, cb )</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">textract.text.</span>types</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.textract.util">module textract.util</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.textract.util.createExecOptions">
            function <span class="apidocSignatureSpan">textract.util.</span>createExecOptions
            <span class="apidocSignatureSpan">( type, options )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.textract.util.getTextFromZipFile">
            function <span class="apidocSignatureSpan">textract.util.</span>getTextFromZipFile
            <span class="apidocSignatureSpan">( zipfile, entry, cb )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.textract.util.replaceBadCharacters">
            function <span class="apidocSignatureSpan">textract.util.</span>replaceBadCharacters
            <span class="apidocSignatureSpan">( text )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.textract.util.runExecIntoFile">
            function <span class="apidocSignatureSpan">textract.util.</span>runExecIntoFile
            <span class="apidocSignatureSpan">( label, filePath, options, execOptions, genCommand, cb )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.textract.util.unzipCheck">
            function <span class="apidocSignatureSpan">textract.util.</span>unzipCheck
            <span class="apidocSignatureSpan">( type, cb )</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.textract.util.yauzlError">
            function <span class="apidocSignatureSpan">textract.util.</span>yauzlError
            <span class="apidocSignatureSpan">( err, cb )</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.textract.xls">module textract.xls</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.textract.xls.extract">
            function <span class="apidocSignatureSpan">textract.xls.</span>extract
            <span class="apidocSignatureSpan">( filePath, options, cb )</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">textract.xls.</span>types</span>

        </li>

    </ol></li>

</ol></div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.textract" id="apidoc.module.textract">module textract</a></h1>


    <h2>
        <a href="#apidoc.element.textract.fromBufferWithMime" id="apidoc.element.textract.fromBufferWithMime">
        function <span class="apidocSignatureSpan">textract.</span>fromBufferWithMime
        <span class="apidocSignatureSpan">( type, bufferContent, options, cb, withPath )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function fromBufferWithMime( type, bufferContent, options, cb, withPath ) {
  if ( typeof type === &#x27;string&#x27; &#x26;&#x26;
       bufferContent &#x26;&#x26;
       bufferContent instanceof Buffer &#x26;&#x26;
       ( typeof options === &#x27;function&#x27; || typeof cb === &#x27;function&#x27; ) ) {
    _writeBufferToDisk( bufferContent, function( newPath ) {
      fromFileWithMimeAndPath( type, newPath, options, cb );
    });
  } else {
    _returnArgsError( arguments );
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
```javascript
textract.fromFileWithMimeAndPath(type, filePath, config, function( error, text ) {})
```

##### Buffer + mime type

```javascript
textract.<span class="apidocCodeKeywordSpan">fromBufferWithMime</span>(type, buffer, function( error, text ) {})
```

```javascript
textract.fromBufferWithMime(type, buffer, config, function( error, text ) {})
```

##### Buffer + file name/path
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.textract.fromBufferWithName" id="apidoc.element.textract.fromBufferWithName">
        function <span class="apidocSignatureSpan">textract.</span>fromBufferWithName
        <span class="apidocSignatureSpan">( filePath, bufferContent, options, cb )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function fromBufferWithName( filePath, bufferContent, options, cb ) {
  var type;
  if ( typeof filePath === &#x27;string&#x27; ) {
    type = mime.lookup( filePath );
    fromBufferWithMime( type, bufferContent, options, cb, true );
  } else {
    _returnArgsError( arguments );
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
```javascript
textract.fromBufferWithMime(type, buffer, config, function( error, text ) {})
```

##### Buffer + file name/path

```javascript
textract.<span class="apidocCodeKeywordSpan">fromBufferWithName</span>(name, buffer, function( error, text ) {})
```

```javascript
textract.fromBufferWithName(name, buffer, config, function( error, text ) {})
```

##### URL
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.textract.fromFileWithMimeAndPath" id="apidoc.element.textract.fromFileWithMimeAndPath">
        function <span class="apidocSignatureSpan">textract.</span>fromFileWithMimeAndPath
        <span class="apidocSignatureSpan">( type, filePath, options, cb )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function fromFileWithMimeAndPath( type, filePath, options, cb ) {
  var called = false;

  if ( typeof type === &#x27;string&#x27; &#x26;&#x26; typeof filePath === &#x27;string&#x27; ) {
    if ( typeof cb === &#x27;function&#x27; &#x26;&#x26; typeof options === &#x27;object&#x27; ) {
      // (mimeType, filePath, options, callback)
      _extractWithType( type, filePath, options, cb );
      called = true;
    } else if ( typeof options === &#x27;function&#x27; &#x26;&#x26; cb === undefined ) {
      // (mimeType, filePath, callback)
      _extractWithType( type, filePath, {}, options );
      called = true;
    }
  }

  if ( !called ) {
    _returnArgsError( arguments );
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

```javascript
textract.fromFileWithPath(filePath, config, function( error, text ) {})
```
##### File + mime type

```javascript
textract.<span class="apidocCodeKeywordSpan">fromFileWithMimeAndPath</span>(type, filePath, function( error, text ) {})
```

```javascript
textract.fromFileWithMimeAndPath(type, filePath, config, function( error, text ) {})
```

##### Buffer + mime type
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.textract.fromFileWithPath" id="apidoc.element.textract.fromFileWithPath">
        function <span class="apidocSignatureSpan">textract.</span>fromFileWithPath
        <span class="apidocSignatureSpan">( filePath, options, cb )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function fromFileWithPath( filePath, options, cb ) {
  var type;
  if ( typeof filePath === &#x27;string&#x27; &#x26;&#x26;
       ( typeof options === &#x27;function&#x27; || typeof cb === &#x27;function&#x27; ) ) {
    type = ( options &#x26;&#x26; options.typeOverride ) || mime.lookup( filePath );
    fromFileWithMimeAndPath( type, filePath, options, cb );
  } else {
    _returnArgsError( arguments );
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
There are several ways to extract text.  For all methods, the extracted text and an error object are passed to a callback.

`error` will contain informative text about why the extraction failed. If textract does not currently extract files of the type
provided, a `typeNotFound` flag will be tossed on the error object.

##### File

```javascript
textract.<span class="apidocCodeKeywordSpan">fromFileWithPath</span>(filePath, function( error, text ) {})
```

```javascript
textract.fromFileWithPath(filePath, config, function( error, text ) {})
```
##### File + mime type
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.textract.fromUrl" id="apidoc.element.textract.fromUrl">
        function <span class="apidocSignatureSpan">textract.</span>fromUrl
        <span class="apidocSignatureSpan">( url, options, cb )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function fromUrl( url, options, cb ) {
  var urlNoQueryParams, extname, filePath, fullFilePath, file, href, callbackCalled;

  // allow url to be either a string or to be a
  // Node URL Object: https://nodejs.org/api/url.html
  href = ( typeof url === &#x27;string&#x27; ) ? url : url.href;

  if ( href ) {
    options = options || {};
    urlNoQueryParams = href.split( &#x27;?&#x27; )[0];
    extname = path.extname( urlNoQueryParams );
    filePath = _genRandom() + extname;
    fullFilePath = path.join( tmpDir, filePath );
    file = fs.createWriteStream( fullFilePath );
    file.on( &#x27;finish&#x27;, function() {
      if ( !callbackCalled ) {
        fromFileWithPath( fullFilePath, options, cb );
      }
    });

    got.stream( url )
      .on( &#x27;response&#x27;, function( response ) {
        // allows for overriding by the developer or automatically
        // populating based on server response.
        if ( !options.typeOverride ) {
          options.typeOverride = response.headers[&#x27;content-type&#x27;].split( /;/ )[0];
        }
      })
      .on( &#x27;error&#x27;, function( error ) {
        var _cb = ( typeof options === &#x27;function&#x27; ) ? options : cb;
        callbackCalled = true;
        _cb( error );
      })
      .pipe( file );
  } else {
    _returnArgsError( arguments );
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
```

##### URL

When passing a URL, the URL can either be a string, or a [node.js URL object](https://nodejs.org/api/url.html). Using the URL object
 allows fine grained control over the URL being used.

```javascript
textract.<span class="apidocCodeKeywordSpan">fromUrl</span>(url, function( error, text ) {})
```

```javascript
textract.fromUrl(url, config, function( error, text ) {})
```

## Testing Notes
...</pre></li>
    </ul>




























</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.textract.docx" id="apidoc.module.textract.docx">module textract.docx</a></h1>


    <h2>
        <a href="#apidoc.element.textract.docx.extract" id="apidoc.element.textract.docx.extract">
        function <span class="apidocSignatureSpan">textract.docx.</span>extract
        <span class="apidocSignatureSpan">( filePath, options, cb )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function extractText( filePath, options, cb ) {
  var result = &#x27;&#x27;;

  yauzl.open( filePath, function( err, zipfile ) {
    var processEnd
      , processedEntries = 0
      ;

    if ( err ) {
      util.yauzlError( err, cb );
      return;
    }

    processEnd = function() {
      var text;
      if ( zipfile.entryCount === ++processedEntries ) {
        if ( result.length ) {
          text = _calculateExtractedText( result );
          cb( null, text );
        } else {
          cb( new Error(
            &#x27;Extraction could not find content in file, are you&#x27; +
            &#x27; sure it is the mime type it says it is?&#x27; ),
            null );
        }
      }
    };

    zipfile.on( &#x27;entry&#x27;, function( entry ) {
      if ( includeRegex.test( entry.fileName ) &#x26;&#x26; !excludeRegex.test( entry.fileName ) ) {
        util.getTextFromZipFile( zipfile, entry, function( err2, text ) {
          result += text + &#x27;\n&#x27;;
          processEnd();
        });
      } else {
        processEnd();
      }
    });

    zipfile.on( &#x27;error&#x27;, function( err3 ) {
      cb( err3 );
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.textract.dxf" id="apidoc.module.textract.dxf">module textract.dxf</a></h1>


    <h2>
        <a href="#apidoc.element.textract.dxf.extract" id="apidoc.element.textract.dxf.extract">
        function <span class="apidocSignatureSpan">textract.dxf.</span>extract
        <span class="apidocSignatureSpan">( filePath, options, cb )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function extractText( filePath, options, cb ) {
  var execOptions = util.createExecOptions( &#x27;dxf&#x27;, options )
    , escapedPath = filePath.replace( /\s/g, &#x27;\\ &#x27; )
    ;

  exec( &#x27;drawingtotext &#x27; + escapedPath,
    execOptions,
    function( error, stdout, stderr ) {
      if ( stderr !== &#x27;&#x27; ) {
        error = new Error( &#x27;error extracting DXF text &#x27; +
          path.basename( filePath ) + &#x27;: &#x27; + stderr );
        cb( error, null );
        return;
      }

      cb( null, stdout );
    }
  );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.textract.dxf.test" id="apidoc.element.textract.dxf.test">
        function <span class="apidocSignatureSpan">textract.dxf.</span>test
        <span class="apidocSignatureSpan">( options, cb )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function testForBinary( options, cb ) {
  exec( &#x27;drawingtotext notalegalfile&#x27;,
    function( error, stdout, stderr ) {
      var msg
        , errorRegex = /I couldn&#x27;t make sense of your input/
        ;

      if ( !( stderr &#x26;&#x26; errorRegex.test( stderr ) ) ) {
        msg = &#x27;INFO: \&#x27;drawingtotext\&#x27; does not appear to be installed, &#x27; +
          &#x27;so textract will be unable to extract DXFs.&#x27;;
        cb( false, msg );
      } else {
        cb( true );
      }
    }
  );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  extractor.types.forEach( function( type ) {
    failedExtractorTypes[type.toLowerCase()] = failedMessage;
  });
}
}

function testExtractor( extractor, options ) {
extractor.<span class="apidocCodeKeywordSpan">test</span>( options, function( passedTest, failedMessage ) {
  satisfiedExtractors++;
  if ( passedTest ) {
    registerExtractor( extractor );
  } else {
    registerFailedExtractor( extractor, failedMessage );
  }
});
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.textract.html" id="apidoc.module.textract.html">module textract.html</a></h1>


    <h2>
        <a href="#apidoc.element.textract.html.extract" id="apidoc.element.textract.html.extract">
        function <span class="apidocSignatureSpan">textract.html.</span>extract
        <span class="apidocSignatureSpan">( filePath, options, cb )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function extractText( filePath, options, cb ) {
  fs.readFile( filePath, function( error, data ) {
    if ( error ) {
      cb( error, null );
      return;
    }
    extractFromText( data, cb );
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.textract.html.extractFromText" id="apidoc.element.textract.html.extractFromText">
        function <span class="apidocSignatureSpan">textract.html.</span>extractFromText
        <span class="apidocSignatureSpan">( data, cb )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function extractFromText( data, cb ) {
  var $, text;

  text = data.toString()
    .replace( /&#x3c; *(br|p|div|section|aside|button|header|footer|li|article|blockquote|cite|code|h1|h2|h3|h4|h5|h6|legend|nav)((.*?)&#x3e;)/
g, &#x27;&#x3c;$1$2|||||&#x27; )
    .replace( /&#x3c; *\/(td|a|option) *&#x3e;/g, &#x27; &#x3c;/$1&#x3e;&#x27; ) // spacing some things out so text doesn&#x27;t get smashed together
    .replace( /&#x3c; *(a|td|option)/g, &#x27; &#x3c;$1&#x27; ) // spacing out links
    .replace( /&#x3c; *(br|hr) +\/&#x3e;/g, &#x27;|||||&#x3c;$1\\&#x3e;&#x27; )
    .replace( /&#x3c;\/ +?(p|div|section|aside|button|header|footer|li|article|blockquote|cite|code|h1|h2|h3|h4|h5|h6|legend|nav)&#x3e;/g, &#x27;|||||&#x3c;/$
1&#x3e;&#x27; );

  text = &#x27;&#x3c;textractwrapper&#x3e;&#x27; + text + &#x27;&#x3c;textractwrapper&#x3e;&#x27;;

  try {
    $ = cheerio.load( text );
    $( &#x27;script&#x27; ).remove();
    $( &#x27;style&#x27; ).remove();
    $( &#x27;noscript&#x27; ).remove();

    text = $( &#x27;textractwrapper&#x27; ).text().replace( /\|\|\|\|\|/g, &#x27;\n&#x27; )
      .replace( /(\n\u00A0|\u00A0\n|\n | \n)+/g, &#x27;\n&#x27; )
      .replace( /(\r\u00A0|\u00A0\r|\r | \r)+/g, &#x27;\n&#x27; )
      .replace( /(\v\u00A0|\u00A0\v|\v | \v)+/g, &#x27;\n&#x27; )
      .replace( /(\t\u00A0|\u00A0\t|\t | \t)+/g, &#x27;\n&#x27; )
      .replace( /[\n\r\t\v]+/g, &#x27;\n&#x27; )
      ;
  } catch ( err ) {
    cb( err, null );
    return;
  }

  cb( null, text );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    return;
  }

  marked( data.toString(), function( err, content ) {
    if ( err ) {
      cb( err, null );
    } else {
      htmlExtract.<span class="apidocCodeKeywordSpan">extractFromText</span>( content, cb );
    }
  });
});
}

module.exports = {
types: [&#x27;text/x-markdown&#x27;],
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.textract.images" id="apidoc.module.textract.images">module textract.images</a></h1>


    <h2>
        <a href="#apidoc.element.textract.images.extract" id="apidoc.element.textract.images.extract">
        function <span class="apidocSignatureSpan">textract.images.</span>extract
        <span class="apidocSignatureSpan">( filePath, options, cb )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function extractText( filePath, options, cb ) {
  var execOptions = util.createExecOptions( &#x27;images&#x27;, options );
  util.runExecIntoFile( &#x27;tesseract&#x27;, filePath, options,
    execOptions, tesseractExtractionCommand, cb );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.textract.images.test" id="apidoc.element.textract.images.test">
        function <span class="apidocSignatureSpan">textract.images.</span>test
        <span class="apidocSignatureSpan">( options, cb )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function testForBinary( options, cb ) {
  exec( &#x27;tesseract&#x27;,
    function( error, stdout, stderr ) {
      var msg;
      // checking for content of help text
      if ( ( error &#x26;&#x26; error.toString().indexOf( &#x27;Usage:&#x27; ) &#x3e; -1 ) ||
          ( stderr &#x26;&#x26; stderr.toString().indexOf( &#x27;Usage:&#x27; ) &#x3e; -1 ) ||
          ( stdout &#x26;&#x26; stdout.toString().indexOf( &#x27;Usage:&#x27; ) &#x3e; -1 ) ) {
        cb( true );
      } else {
        msg = &#x27;INFO: \&#x27;tesseract\&#x27; does not appear to be installed, &#x27; +
         &#x27;so textract will be unable to extract images.&#x27;;
        cb( false, msg );
      }
    }
  );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  extractor.types.forEach( function( type ) {
    failedExtractorTypes[type.toLowerCase()] = failedMessage;
  });
}
}

function testExtractor( extractor, options ) {
extractor.<span class="apidocCodeKeywordSpan">test</span>( options, function( passedTest, failedMessage ) {
  satisfiedExtractors++;
  if ( passedTest ) {
    registerExtractor( extractor );
  } else {
    registerFailedExtractor( extractor, failedMessage );
  }
});
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.textract.md" id="apidoc.module.textract.md">module textract.md</a></h1>


    <h2>
        <a href="#apidoc.element.textract.md.extract" id="apidoc.element.textract.md.extract">
        function <span class="apidocSignatureSpan">textract.md.</span>extract
        <span class="apidocSignatureSpan">( filePath, options, cb )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function extractText( filePath, options, cb ) {
  fs.readFile( filePath, function( error, data ) {
    if ( error ) {
      cb( error, null );
      return;
    }

    marked( data.toString(), function( err, content ) {
      if ( err ) {
        cb( err, null );
      } else {
        htmlExtract.extractFromText( content, cb );
      }
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.textract.odt" id="apidoc.module.textract.odt">module textract.odt</a></h1>


    <h2>
        <a href="#apidoc.element.textract.odt.extract" id="apidoc.element.textract.odt.extract">
        function <span class="apidocSignatureSpan">textract.odt.</span>extract
        <span class="apidocSignatureSpan">( filePath, options, cb )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function extractText( filePath, options, cb ) {
  yauzl.open( filePath, function( err, zipfile ) {
    var textOnTheWay = false;

    if ( err ) {
      util.yauzlError( err, cb );
      return;
    }

    zipfile.on( &#x27;end&#x27;, function() {
      if ( !textOnTheWay ) {
        cb(
          new Error( &#x27;Extraction could not find content.xml in file, &#x27; +
            &#x27;are you sure it is the mime type it says it is?&#x27; ),
          null );
      }
    });

    zipfile.on( &#x27;entry&#x27;, function( entry ) {
      if ( entry.fileName === &#x27;content.xml&#x27; ) {
        textOnTheWay = true;
        util.getTextFromZipFile( zipfile, entry, function( err2, text ) {
          var output = text
              .replace( &#x27;inflating: content.xml&#x27;, &#x27;&#x27; )
              .replace( /^(.Archive).*/, &#x27;&#x27; )
              .replace( /text:p/g, &#x27;textractTextNode&#x27; )
              .replace( /text:h/g, &#x27;textractTextNode&#x27; )
              .replace( /&#x3c;textractTextNode\/&#x3e;/g, &#x27;&#x27; )
              .trim()
            , $ = cheerio.load( &#x27;&#x3c;body&#x3e;&#x27; + output + &#x27;&#x3c;/body&#x3e;&#x27; )
            , nodes = $( &#x27;textractTextNode&#x27; )
            , nodeTexts = []
            , i
            ;

          for ( i = 0; i &#x3c; nodes.length; i++ ) {
            nodeTexts.push( $( nodes[i] ).text() );
          }

          cb( null, nodeTexts.join( &#x27;\n&#x27; ) );
        });
      }
    });

    zipfile.on( &#x27;error&#x27;, function( err3 ) {
      cb( err3 );
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.textract.pdf" id="apidoc.module.textract.pdf">module textract.pdf</a></h1>


    <h2>
        <a href="#apidoc.element.textract.pdf.extract" id="apidoc.element.textract.pdf.extract">
        function <span class="apidocSignatureSpan">textract.pdf.</span>extract
        <span class="apidocSignatureSpan">( filePath, options, cb )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function extractText( filePath, options, cb ) {
  // See https://github.com/dbashford/textract/issues/75 for description of
  // what is happening here
  var pdftotextOptions = options.pdftotextOptions || { layout: &#x27;raw&#x27; };

  extract( filePath, pdftotextOptions, function( error, pages ) {
    var fullText;
    if ( error ) {
      error = new Error( &#x27;Error extracting PDF text for file at [[ &#x27; +
        path.basename( filePath ) + &#x27; ]], error: &#x27; + error.message );
      cb( error, null );
      return;
    }
    fullText = pages.join( &#x27; &#x27; ).trim();
    cb( null, fullText );
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.textract.pdf.test" id="apidoc.element.textract.pdf.test">
        function <span class="apidocSignatureSpan">textract.pdf.</span>test
        <span class="apidocSignatureSpan">( options, cb )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function testForBinary( options, cb ) {
  exec( &#x27;pdftotext -v&#x27;,
    function( error, stdout, stderr ) {
      var msg;
      if ( stderr &#x26;&#x26; stderr.indexOf( &#x27;pdftotext version&#x27; ) &#x3e; -1 ) {
        cb( true );
      } else {
        msg = &#x27;INFO: \&#x27;pdftotext\&#x27; does not appear to be installed, &#x27; +
         &#x27;so textract will be unable to extract PDFs.&#x27;;
        cb( false, msg );
      }
    }
  );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  extractor.types.forEach( function( type ) {
    failedExtractorTypes[type.toLowerCase()] = failedMessage;
  });
}
}

function testExtractor( extractor, options ) {
extractor.<span class="apidocCodeKeywordSpan">test</span>( options, function( passedTest, failedMessage ) {
  satisfiedExtractors++;
  if ( passedTest ) {
    registerExtractor( extractor );
  } else {
    registerFailedExtractor( extractor, failedMessage );
  }
});
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.textract.ppt" id="apidoc.module.textract.ppt">module textract.ppt</a></h1>


    <h2>
        <a href="#apidoc.element.textract.ppt.extract" id="apidoc.element.textract.ppt.extract">
        function <span class="apidocSignatureSpan">textract.ppt.</span>extract
        <span class="apidocSignatureSpan">( filePath, options, cb )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">extract = function ( filePath, options, cb ) {
<span class="apidocCodeCommentSpan">  /*
  var captured = ppt.readFile(filePath);
  console.log(&#x27;CAPTURED!!!!&#x27;)
  console.log(captured)
  console.log(&#x27;CAPTURED!!!!&#x27;)
  cb( null, null );
    if ( error ) {
      cb( error, null );
      return;
    }
    cb( null, data.toString() );
  */
</span>}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.textract.pptx" id="apidoc.module.textract.pptx">module textract.pptx</a></h1>


    <h2>
        <a href="#apidoc.element.textract.pptx.extract" id="apidoc.element.textract.pptx.extract">
        function <span class="apidocSignatureSpan">textract.pptx.</span>extract
        <span class="apidocSignatureSpan">( filePath, options, cb )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function extractText( filePath, options, cb ) {
  var slides = [];

  yauzl.open( filePath, function( err, zipfile ) {
    if ( err ) {
      util.yauzlError( err, cb );
      return;
    }

    zipfile.on( &#x27;end&#x27;, function() {
      var slidesText, text;
      if ( slides.length ) {
        slides.sort( _compareSlides );
        slidesText = slides.map( function( slide ) {
          return slide.text;
        }).join( &#x27;\n&#x27; );
        text = _calculateExtractedText( slidesText );
        cb( null, text );
      } else {
        cb(
          new Error( &#x27;Extraction could not find slides in file, are you&#x27; +
            &#x27; sure it is the mime type it says it is?&#x27; ),
          null );
      }
    });

    zipfile.on( &#x27;entry&#x27;, function( entry ) {
      if ( slideMatch.test( entry.fileName ) ) {
        util.getTextFromZipFile( zipfile, entry, function( err2, text ) {
          var slide = +entry.fileName.replace( &#x27;ppt/slides/slide&#x27;, &#x27;&#x27; ).replace( &#x27;.xml&#x27;, &#x27;&#x27; );
          slides.push({ slide: slide, text: text });
        });
      }
    });

    zipfile.on( &#x27;error&#x27;, function( err3 ) {
      cb( err3 );
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.textract.rtf" id="apidoc.module.textract.rtf">module textract.rtf</a></h1>


    <h2>
        <a href="#apidoc.element.textract.rtf.extract" id="apidoc.element.textract.rtf.extract">
        function <span class="apidocSignatureSpan">textract.rtf.</span>extract
        <span class="apidocSignatureSpan">( filePath, options, cb )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function extractText( filePath, options, cb ) {
  var escapedPath = filePath.replace( /\s/g, &#x27;\\ &#x27; );

  // Going to output html from unrtf because unrtf does a great job of
  // going to html, but does a crap job of going to text. It leaves sections
  // out, strips apostrophes, leaves nasty quotes in for bullets and more
  // that I&#x27;ve likely not yet discovered.
  //
  // textract can go from html to text on its own, so let unrtf go to html
  // then extract the text from that
  //
  // Also do not have to worry about stripping comments from unrtf text
  // output since HTML comments are not included in output. Also, the
  // unrtf --quiet option doesn&#x27;t work.
  exec( &#x27;unrtf --html --nopict &#x27; + escapedPath,
    function( error, stdout /* , stderr */ ) {
      var err;
      if ( error ) {
        err = new Error( &#x27;unrtf read of file named [[ &#x27; +
          path.basename( filePath ) + &#x27; ]] failed: &#x27; + error );
        cb( err, null );
      } else {
        htmlExtract.extractFromText( stdout.trim(), cb );
      }
    }
  );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.textract.rtf.test" id="apidoc.element.textract.rtf.test">
        function <span class="apidocSignatureSpan">textract.rtf.</span>test
        <span class="apidocSignatureSpan">( options, cb )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function testForBinary( options, cb ) {
  // just non-osx extractor
  if ( os.platform() === &#x27;darwin&#x27; ) {
    cb( true );
    return;
  }

  exec( &#x27;unrtf &#x27; + __filename,
    function( error /* , stdout, stderr */ ) {
      var msg;
      if ( error !== null &#x26;&#x26; error.message &#x26;&#x26;
          error.message.indexOf( &#x27;not found&#x27; ) !== -1 ) {
        msg = &#x27;INFO: \&#x27;unrtf\&#x27; does not appear to be installed, &#x27; +
          &#x27;so textract will be unable to extract RTFs.&#x27;;
        cb( false, msg );
      } else {
        cb( true );
      }
    }
  );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  extractor.types.forEach( function( type ) {
    failedExtractorTypes[type.toLowerCase()] = failedMessage;
  });
}
}

function testExtractor( extractor, options ) {
extractor.<span class="apidocCodeKeywordSpan">test</span>( options, function( passedTest, failedMessage ) {
  satisfiedExtractors++;
  if ( passedTest ) {
    registerExtractor( extractor );
  } else {
    registerFailedExtractor( extractor, failedMessage );
  }
});
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.textract.text" id="apidoc.module.textract.text">module textract.text</a></h1>


    <h2>
        <a href="#apidoc.element.textract.text.extract" id="apidoc.element.textract.text.extract">
        function <span class="apidocSignatureSpan">textract.text.</span>extract
        <span class="apidocSignatureSpan">( filePath, options, cb )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function extractText( filePath, options, cb ) {
  fs.readFile( filePath, function( error, data ) {
    var encoding, decoded;
    if ( error ) {
      cb( error, null );
      return;
    }
    try {
      encoding = jschardet.detect( data ).encoding.toLowerCase();
      decoded = iconv.decode( data, encoding );
    } catch ( e ) {
      cb( e );
      return;
    }
    cb( null, decoded );
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.textract.util" id="apidoc.module.textract.util">module textract.util</a></h1>


    <h2>
        <a href="#apidoc.element.textract.util.createExecOptions" id="apidoc.element.textract.util.createExecOptions">
        function <span class="apidocSignatureSpan">textract.util.</span>createExecOptions
        <span class="apidocSignatureSpan">( type, options )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createExecOptions( type, options ) {
  var execOptions = {};
  if ( options[type] &#x26;&#x26; options[type].exec ) {
    execOptions = options[type].exec;
  } else {
    if ( options.exec ) {
      execOptions = options.exec;
    }
  }
  return execOptions;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var exec = require( &#x27;child_process&#x27; ).exec
, path = require( &#x27;path&#x27; )
, util = require( &#x27;../util&#x27; )
;

function extractText( filePath, options, cb ) {
var execOptions = util.<span class="apidocCodeKeywordSpan">createExecOptions</span>( &#x27;dxf&#x27;, options )
  , escapedPath = filePath.replace( /\s/g, &#x27;\\ &#x27; )
  ;

exec( &#x27;drawingtotext &#x27; + escapedPath,
  execOptions,
  function( error, stdout, stderr ) {
    if ( stderr !== &#x27;&#x27; ) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.textract.util.getTextFromZipFile" id="apidoc.element.textract.util.getTextFromZipFile">
        function <span class="apidocSignatureSpan">textract.util.</span>getTextFromZipFile
        <span class="apidocSignatureSpan">( zipfile, entry, cb )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getTextFromZipFile( zipfile, entry, cb ) {
  zipfile.openReadStream( entry, function( err, readStream ) {
    var text = &#x27;&#x27;
      , error = &#x27;&#x27;
      ;

    if ( err ) {
      cb( err, null );
      return;
    }

    readStream.on( &#x27;data&#x27;, function( chunk ) {
      text += chunk;
    });
    readStream.on( &#x27;end&#x27;, function() {
      if ( error.length &#x3e; 0 ) {
        cb( error, null );
      } else {
        cb( null, text );
      }
    });
    readStream.on( &#x27;error&#x27;, function( _err ) {
      error += _err;
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        null );
    }
  }
};

zipfile.on( &#x27;entry&#x27;, function( entry ) {
  if ( includeRegex.test( entry.fileName ) &#x26;&#x26; !excludeRegex.test( entry.fileName ) ) {
    util.<span class="apidocCodeKeywordSpan">getTextFromZipFile</span>( zipfile, entry, function( err2, text ) {
      result += text + &#x27;\n&#x27;;
      processEnd();
    });
  } else {
    processEnd();
  }
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.textract.util.replaceBadCharacters" id="apidoc.element.textract.util.replaceBadCharacters">
        function <span class="apidocSignatureSpan">textract.util.</span>replaceBadCharacters
        <span class="apidocSignatureSpan">( text )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function replaceBadCharacters( text ) {
  var i, repl;
  for ( i = 0; i &#x3c; rLen; i++ ) {
    repl = replacements[i];
    text = text.replace( repl[0], repl[1] );
  }
  return text;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}

// global, all file type, content cleansing
function cleanseText( options, cb ) {
  return function( error, text ) {
    if ( !error ) {
// clean up text
text = util.<span class="apidocCodeKeywordSpan">replaceBadCharacters</span>( text );

if ( options.preserveLineBreaks ) {
  text = text.replace( WHITELIST_PRESERVE_LINEBREAKS, &#x27; &#x27; );
} else {
  text = text.replace( WHITELIST_STRIP_LINEBREAKS, &#x27; &#x27; );
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.textract.util.runExecIntoFile" id="apidoc.element.textract.util.runExecIntoFile">
        function <span class="apidocSignatureSpan">textract.util.</span>runExecIntoFile
        <span class="apidocSignatureSpan">( label, filePath, options, execOptions, genCommand, cb )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function runExecIntoFile( label, filePath, options, execOptions, genCommand, cb ) {
  // escape the file paths
  var fileTempOutPath = path.join( outDir, path.basename( filePath, path.extname( filePath ) ) )
    , escapedFilePath = filePath.replace( /\s/g, &#x27;\\ &#x27; )
    , escapedFileTempOutPath = fileTempOutPath.replace( /\s/g, &#x27;\\ &#x27; )
    , cmd = genCommand( options, escapedFilePath, escapedFileTempOutPath )
    ;

  exec( cmd, execOptions,
    function( error /* , stdout, stderr */ ) {
      if ( error !== null ) {
        error = new Error( &#x27;Error extracting [[ &#x27; +
          path.basename( filePath ) + &#x27; ]], exec error: &#x27; + error.message );
        cb( error, null );
        return;
      }

      fs.exists( fileTempOutPath + &#x27;.txt&#x27;, function( exists ) {
        if ( exists ) {
          fs.readFile( fileTempOutPath + &#x27;.txt&#x27;, &#x27;utf8&#x27;, function( error2, text ) {
            if ( error2 ) {
              error2 = new Error( &#x27;Error reading&#x27; + label +
                &#x27; output at [[ &#x27; + fileTempOutPath + &#x27; ]], error: &#x27; + error.message );
              cb( error2, null );
            } else {
              fs.unlink( fileTempOutPath + &#x27;.txt&#x27;, function( error3 ) {
                if ( error3 ) {
                  error3 = new Error( &#x27;Error, &#x27; + label +
                    &#x27; , cleaning up temp file [[ &#x27; + fileTempOutPath +
                    &#x27; ]], error: &#x27; + error.message );
                  cb( error3, null );
                } else {
                  cb( null, text.toString() );
                }
              });
            }
          });
        } else {
          error = new Error( &#x27;Error reading &#x27; + label +
            &#x27; output at [[ &#x27; + fileTempOutPath + &#x27; ]], file does not exist&#x27; );
          cb( error, null );
        }
      });
    }
  );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}
cmd += &#x27; quiet&#x27;;
return cmd;
}

function extractText( filePath, options, cb ) {
var execOptions = util.createExecOptions( &#x27;images&#x27;, options );
util.<span class="apidocCodeKeywordSpan">runExecIntoFile</span>( &#x27;tesseract&#x27;, filePath, options,
  execOptions, tesseractExtractionCommand, cb );
}

function testForBinary( options, cb ) {
exec( &#x27;tesseract&#x27;,
  function( error, stdout, stderr ) {
    var msg;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.textract.util.unzipCheck" id="apidoc.element.textract.util.unzipCheck">
        function <span class="apidocSignatureSpan">textract.util.</span>unzipCheck
        <span class="apidocSignatureSpan">( type, cb )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function unzipCheck( type, cb ) {
  exec( &#x27;unzip&#x27;,
    function( error /* , stdout, stderr */ ) {
      if ( error ) {
        // eslint-disable-next-line no-console
        console.error( &#x27;textract: \&#x27;unzip\&#x27; does not appear to be installed, &#x27; +
          &#x27;so textract will be unable to extract &#x27; + type + &#x27;.&#x27; );
      }
      cb( error === null );
    }
  );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.textract.util.yauzlError" id="apidoc.element.textract.util.yauzlError">
        function <span class="apidocSignatureSpan">textract.util.</span>yauzlError
        <span class="apidocSignatureSpan">( err, cb )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function yauzlError( err, cb ) {
  var msg = err.message;
  if ( msg === &#x27;end of central directory record signature not found&#x27; ) {
    msg = &#x27;File not correctly recognized as zip file, &#x27; + msg;
  }
  cb( new Error( msg ), null );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

  yauzl.open( filePath, function( err, zipfile ) {
var processEnd
  , processedEntries = 0
  ;

if ( err ) {
  util.<span class="apidocCodeKeywordSpan">yauzlError</span>( err, cb );
  return;
}

processEnd = function() {
  var text;
  if ( zipfile.entryCount === ++processedEntries ) {
    if ( result.length ) {
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.textract.xls" id="apidoc.module.textract.xls">module textract.xls</a></h1>


    <h2>
        <a href="#apidoc.element.textract.xls.extract" id="apidoc.element.textract.xls.extract">
        function <span class="apidocSignatureSpan">textract.xls.</span>extract
        <span class="apidocSignatureSpan">( filePath, options, cb )</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function extractText( filePath, options, cb ) {
  var CSVs, wb, result, error;

  try {
    wb = J.readFile( filePath );
    CSVs = J.utils.to_csv( wb );
  } catch ( err ) {
    error = new Error( &#x27;Could not extract &#x27; + path.basename( filePath ) + &#x27;, &#x27; + err );
    cb( error, null );
    return;
  }

  result = &#x27;&#x27;;
  Object.keys( CSVs ).forEach( function( key ) {
    result += CSVs[key];
  });

  cb( null, result );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocFooterDiv">
    [ this document was created with
    <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a>
    ]
</div>
</div>
